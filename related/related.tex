\chapter{Related works}
\label{chap:related}

Most Solidity analysis tools currently still revolve around programme verification, such 
as Oyente, Mythril, and Manticore. These tools focus on analysing reachable vulnerable
states within a smart contract, and checks for common exploits such as reentrancy and unprotected
self destructs, and ultimately differ from the objectives of this project. MadMax is a
verification tool that focuses on detecting states that may result in an out of gas error, but
also does not focus on calculating gas bounds for smart contract functions, and therefore
remains out of scope. Here, we will discuss two related projects, GASTAP and VisualGas, which
both focus on a similar objective of estimating gas costs with two different approaches.

\section{GASTAP}

\subsection{Summary}

GASTAP is a tool developed by Albert et al \cite{dontrunonfumes} that claims to be able to
infer parametric gas bounds for smart contracts. These inferred bounds may depend on the
function arguments provided, or on the blockchain and smart contract state. GASTAP conducts
its analysis on the EVM bytecode level, for which the schedule of gas fees is defined.

GASTAP achieves this in 3 stages. First, it generates a \textit{stack-sensitive control flow graph (S-CFG)}
for the EVM bytecode. To do this, it first calculates the set of basic blocks in an EVM programme,
and detects the set of valid jump destinations (marked by the \texttt{JUMPDEST} instruction). Then,
they proceed via symbolic execution for each block to produce the stack state after executing each EVM instruction.
The key idea here is that since \texttt{JUMP} instructions jump to the programme counter at the 
top of the stack, control flow when reaching a basic block therefore then depends on the set 
of stack items at that point which hold valid jump destinations. Thus, if two execution traces
reach the same basic block with the same set and locations of jump destinations in their stacks, 
their nodes in the control flow graph can be safely merged. Else, a new node for the new stack
state is pushed into the control flow graph, and the process repeats iteratively until the graph
is consistent. Their earlier paper also provides a proof for how this model is sound and over-approximates 
the jumping information for a programme \cite{constructcfg}. The tool they used to perform this step -- 
EthIR, an extension of the Oyente tool -- is also open source and available on their GitHub repository.

Next, GASTAP produces a \textit{rule-based representation (GAS-RBR)} from the S-CFG generated in the previous step.
Each for each block, a new rule is constructed, with the edges indicating invocations of the generated
rules. The original EVM instructions are wrapped in a \textit{nop} functor within the GAS-RBR, to
allow for precise calculation of the gas costs later on. This representation essentially abstracts
the relationships between different items within the stack, as well as the boolean guards involved
involved in making conditional jumps. Then, in order to calculate gas bounds, GASTAP also defines 
a set of semantics for the GAS-RBR, and separates the gas costs into two parts -- the \textit{opcode cost}
and the \textit{memory cost}. The opcode semantics takes the EVM opcode, the state of the stack, and
the mapping of state variables when reading the opcode to return the corresponding gas cost 
of the instruction. The memory semantics similarly returns the highest memory slot used 
by an EVM instruction, since memory gas cost is only determined by each expansion of memory slot
as introduced in Section \ref{evm:gas}.

Finally, the current GAS-RBR allows for the calculation of gas costs for concrete executions,
for which all parameters involved are known concretely. However, in order to calculate parametric
bounds, GASTAP first transforms the local memory and storage accesses by the GAS-RBR into local variables.
Then, it makes use of a resource analysis tool called \textsc{Saco} to solve the constraints set by the GAS-RBR,
and output a final parametric gas cost of a function call. This is the main contribution of this project,
as there is no other tool available to our knowledge that is able to produce a parametric bound on gas costs.

\subsection{Results}

GASTAP is then evaluated against 34,000 Ethereum smart contracts, which was completed in 407.5 hours, or around 16
days of execution time. It was also found that GASTAP had a failure rate of 0.85\%. Then, the gas bounds
generated by GASTAP was evaluated against 4000 transactions of 300 top-valued Ether smart contracts.
The average precision obtained was not published, but the overhead calculated from GASTAP was about
10\% to 50\% of the real transaction gas costs, with some overheads of up to 600\% recorded. 
The authors claim this is because GASTAP has to take into account all possible input values, in order
to calculate the worst case bounds.

\subsection{Limitations}

Some limitations of the GASTAP tool is that it only calculates gas bounds on a function-call level,
similar to the Solidity compiler but with possibly greater precision. Our project aims to improve on
this by calculating gas used for each line of Solidity code. 

In addition, the GASTAP demo is no longer
working or being maintained, and their latest supported version of Solidity is 0.7.1, which was released
in September 2020. In addition, the \textsc{Saco} analyser used was developed by themselves and is
closed-source, with no available binaries to the public, and we could not verify their claims.

\section{VisualGas}

\subsection{Summary}

VisualGas is a tool developed by Signer \cite{visualgas} with a similar goal for allowing developers 
to visualise the gas costs incurred by each line of code, and test best and worst case executions
before deployment. However, in contrast to the static resource analysis of GASTAP, and our
proposed implementation of symbolic execution, VisualGas makes use of dynamic programme analysis
to estimate gas bounds of each instruction. \cite{visualgas} claims that this method is more precise
than static analysis, although may possibly lead to less coverage.

VisualGas was implemented in 3 parts. First, since dynamic analysis is performed, VisualGas needs 
a way to collect traces of executions of a given smart contract. It uses a Go-Ethereum client 
locally to execute transactions, and collects traces in the form of what instruction was
executed at which programme counter (PC), the remaining amount of gas, the gas cost of each step,
the call stack depth and memory state, as well as any storage slots accessed at each step. This trace
collection is repeated for every new test input state that is generated. Then,
it uses the source mapping of build artifacts generated by Truffle, and processes it to map
programme counters to specific lines of code. The gas costs of each trace is then aggregated 
and further processed to take into account refunds and external calls. Finally, a histogram of
gas costs for each line of code across all executed traces is output. For programme counters that were
never executed, only the static gas costs are calculated, but this may not be accurate or sound.

Next, in order generate the test inputs, a fuzzer by Ambroladze et al \cite{visualgas_fuzzer} is used. This generates 
transactions to run all public functions within a smart contract, and uses a feedbackloop to adjust
arguments so as to achieve high code coverage. It also takes into account the timestamp of the deployment
transaction, and fuzzes the block timestamps to execute functions that require a certain time to have passed.


Finally, to visualise the analysis, a webserver built on Flask was used, which links all three
analysis components together.

\subsection{Results}
VisualGas reports a 88\% average (and 94\% median) code coverage for their fuzzer with a limit of 
5,000 transactions, when testing against a dataset of 30,400 contracts with less than 6,000 EVM
instructions. They also report that larger contracts seemed to have lower coverage at that limit.

As for gas analysis, VisualGas did not evaluate their tool against a large dataset of contracts,
or provide any measurement of precision for their analysis. Instead, they performed a case study
on a TimedCrowdSale smart contract \cite{visualgas_timedcrowdsale}, and reported a running time 
of 45s and 82s for executing 5000 transactions and 10000 transactions respectively. They also 
claim a 99\% code coverage for the SimpleToken contract, and a 95\% coverage for the 
MyTimedCrowdSaleContract. However, no measurement of precision was provided for the contracts tested
as well.

\subsection{Limitations}
Although VisualGas is closest to this project in terms of objectives, and aims to produce a gas cost estimate 
for every line of code, their implementation
does not attempt to be sound or precise, considering the lack of evaluation for the precision 
of gas costs calculated. Rather, VisualGas at best serves to only provide a rough visualisation
of which parts of code appear to be the most gas-consuming. In addition, their use of dynamic 
analysis in the form of programme traces results in a relatively average low code coverage of 88\%, with a
relatively high running time required to collect all traces. This is not ideal, since a large part of
gas costs might still be hidden away within the code paths that were not traversed. Our implementation
addresses this via symbolic execution, which reasons about a programme path-by-path rather than 
input-by-input, and can be significantly more efficient.

VisualGas also did not state their latest supported Solidity version, although images from their
paper suggests this is 0.4.25, which was released more than 3 years ago. There is also no source code
provided, and therefore we are unable to test their tool.



\section{Summary of Research}
From our findings, we discover that no current existing tool performs the objectives of this project
well. GASTAP has a sophisticated static analysis framework and can notably derive parametric gas
bounds in terms of function arguments, but only provides these at a transaction level rather than
a per line-of-code level. VisualGas performs dynamic analysis to derive gas costs for each line of
code, but has lower coverage and the precision of their estimates remains unknown.

Our project therefore aims to improve on these tools, by providing a gas cost estimate for each line
of code, and enabling high code coverage via symbolic execution. We also plan to enhance the 
gas estimation of loops by performing static analysis on the Yul intermediate representation,
to derive a parametric bound on the number of loop invocations.
